const fs = require('fs');
const path = require('path');

function getAllFoldersInFolder(folderPath, folders = []) {
    const contents = fs.readdirSync(folderPath);
  
    contents.forEach(item => {
      const itemPath = path.join(folderPath, item);
      if (fs.statSync(itemPath).isDirectory()) {
        folders.push(itemPath);
        getAllFoldersInFolder(itemPath, folders);
      }
    });
  
    return folders;
  }
  
  // Replace 'your/folder/path' with the actual path to your folder
  const folderPath = './Classified_Opcodes_Filtered';
  const allFolders = getAllFoldersInFolder(folderPath);

const bigrams = new Set()

function readFilesSync(dir) {
    const files = [];

    fs.readdirSync(dir).forEach(filename => {
        const name = path.parse(filename).name;
        const ext = path.parse(filename).ext;
        const filepath = path.resolve(dir, filename);
        const stat = fs.statSync(filepath);
        const isFile = stat.isFile();

        if (isFile) files.push({ filepath, name, ext, stat });
    });
    console.log("All files extracted");
    return files;
}

function generateBigrams(text) {
    const words = text.split(/\s+/);
  
    for (let i = 0; i < words.length - 1; i++) {
      bigrams.add(words[i].concat(words[i+1]));
    }
  }

allFolders.forEach(folder => {
    const files = readFilesSync(`${folder}/`)

    for(let i=0;i<files.length;i++)
    {
        try{
            let file = files[i]
    
            const data = fs.readFileSync(file.filepath, 'utf8');
            generateBigrams(data)
    
            //console.log(`File ${i} successfully read`);
        }catch(err){
            console.log("This file has some issue ",err)
        }
    }
})

console.log(bigrams.size)

const csvTable = []


allFolders.forEach(folder => {

    const files = readFilesSync(`${folder}/`)

    for(let i=0;i<files.length;i++)
    {
        try{
            let file = files[i]
    
            const text = fs.readFileSync(file.filepath,'utf8');
            const words = text.split(/\s+/);
    
            const map = new Map([])
    
            for (let i = 0; i < words.length - 1; i++){
                if(map.has(words[i].concat(words[i+1]))){
                    map.set(words[i].concat(words[i+1]),parseInt(map.get(words[i].concat(words[i+1]),10))+1);
                }else{
                    map.set(words[i].concat(words[i+1]),1);
                }
            }
    
            const row = new Map([])
    
            for(const feature of bigrams){
                if(map.has(feature))
                {
                    row.set(feature,parseInt(map.get(feature))/(words.length - 1))
                }else{
                    row.set(feature,0);
                }
            }
            row.set("TARGET",`${folder}`)
            csvTable.push(row);
            console.log(`${i} file pushed in csvTable`);
        }catch(err){
            console.log("This file has some issue ",err);
        }
    }
})

// for(let [key,value] of csvTable[0])
// {
//     console.log(key + "=" + value)
// }

function convertToCSV(data) {
    try{
        let headerArr = []
        for(let [key,value] of csvTable[0])
        {
            headerArr.push(key);
        }
        const header = headerArr.join(',');
        const rows = []
        for(let obj of csvTable)
        {
            let tmp = []
            for(let [key,value] of obj){
                tmp.push(value)
            }
            let row = tmp.join(',');
            rows.push(row);
        }
        return [header, ...rows].join('\n');
    }catch(err){
        console.log("Can't be converted in CSV",err)
    }
  }
  
  const csvContent = convertToCSV(csvTable);
  
  // Specify the file path
  const filePath = 'classified_opcodes_filtered_bigrams.csv';
  
  // Write the CSV content to the file
  fs.writeFileSync(filePath, csvContent);
  
  console.log(`CSV file has been created at ${filePath}`);



