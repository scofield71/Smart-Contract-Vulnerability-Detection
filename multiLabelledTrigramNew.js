const fs = require('fs');

const mapOfArrays = new Map();

function addToArrayInMap(map, key, value) {
    // If the key doesn't exist in the map, create a new array
    if (!map.has(key)) {
        map.set(key, []);
    }
    // Add the value to the array corresponding to the key
    map.get(key).push(value);
}

function existsInArrayInMap(map, key, value) {
    // If the key exists in the map, check if the value exists in its array
    return map.has(key) && map.get(key).includes(value);
}



function readFileSynchronously(filePath) {
    try {
        // Read file synchronously
        const data = fs.readFileSync(filePath, 'utf8');
        // Perform business operations here with the data
        const lines = data.split('\n');
        let allFiles = [];
        lines.forEach(line => {
            // Split the line into words
            const words = line.split(' ');
            // Iterate over each word
            let index = words[0].indexOf('_');
            let key = words[0].substring(0,index);
            key+=".txt";
            allFiles.push(key);
            for(let i=1;i<words.length;i++){
                addToArrayInMap(mapOfArrays,key,words[i]);
            }
        });
        return allFiles;

    } catch (err) {
        console.error('Error reading file:', err);
        return null; // or handle error as per your requirement
    }
}

const allFileNames = readFileSynchronously('scrawld_majority_unique.txt')
console.log("All file names are extracted and vulnerabilities are stored in map");

//Now performing operations to generate trigrams
const trigrams = new Set()

function readFilesSync(dir) {
    const files = [];

    fs.readdirSync(dir).forEach(filename => {
        //console.log(filename);
        // const name = path.parse(filename).name;
        // const ext = path.parse(filename).ext;
        // const filepath = path.resolve(dir, filename);
        // const stat = fs.statSync(filepath);
        // const isFile = stat.isFile();

        files.push(filename);
    });
    console.log("All files extracted");
    return files;
}

function generateBigrams(text) {
    const words = text.split(/\s+/);
  
    for (let i = 0; i < words.length - 2; i++) {
      trigrams.add(words[i].concat('-').concat(words[i+1]).concat('-').concat(words[i+2]).concat('-').concat(words[i+2]));
    }
}

const files = readFilesSync("sujeetDatasetCompiled_Filtered/")
// console.log(files);

for(let i=0;i<files.length;i++)
{
    try{
        let file = files[i]

        const data = fs.readFileSync(`sujeetDatasetCompiled_Filtered/${file}`, 'utf8');
        generateBigrams(data)

        //console.log(`File ${i} successfully read`);
    }catch(err){
        console.log("This file has some issue ",err)
    }
}

console.log("The total number of trigrams are " + trigrams.size);
// console.log(mapOfArrays);
// console.log("Now we will convert the data in CSV format");

// const csvTable = []
// const vulnerabilities = ["ARTHM","DOS","LE","RENT","TimeM","TimeO","Tx-Origin","UE"];
// for(let i=1;i<2000;i++){
//     try{
//         let file = files[i];
//         const text = fs.readFileSync(`sujeetDatasetCompiled_Filtered/${file}`,'utf8');
//         const words = text.split(/\s+/);

//         const map = new Map([])

//         for (let i = 0; i < words.length - 2; i++){
//             if(map.has(words[i].concat('-').concat(words[i+1]).concat('-').concat(words[i+2]))){
//                 map.set(words[i].concat('-').concat(words[i+1]).concat('-').concat(words[i+2]),parseInt(map.get(words[i].concat('-').concat(words[i+1]).concat('-').concat(words[i+2]),10))+1);
//             }else{
//                 map.set(words[i].concat('-').concat(words[i+1]).concat('-').concat(words[i+2]),1);
//             }
//         }

//         const row = new Map([])

//         for(const feature of trigrams){
//             if(map.has(feature))
//             {
//                 row.set(feature,parseInt(map.get(feature))/(words.length - 1))
//             }else{
//                 row.set(feature,0);
//             }
//         }
//         for(let vulnerability of vulnerabilities){
//             if(existsInArrayInMap(mapOfArrays,file,vulnerability)){
//                 row.set(vulnerability,1);
//             }else{
//                 row.set(vulnerability,0);
//             }
//         }
//         csvTable.push(row);
//         console.log(`${i} file pushed in csvTable`);

//     }catch(error){
//         console.log(`${files[i]} has some error `,error)
//     }
// }

// //console.log(csvTable);

// function convertToCSV(data) {
//     try{
//         let headerArr = []
//         for(let [key,value] of csvTable[0])
//         {
//             headerArr.push(key);
//         }
//         const header = headerArr.join(',');
//         const rows = []
//         for(let obj of csvTable)
//         {
//             let tmp = []
//             for(let [key,value] of obj){
//                 tmp.push(value)
//             }
//             let row = tmp.join(',');
//             rows.push(row);
//         }
//         return [header, ...rows].join('\n');
//     }catch(err){
//         console.log("Can't be converted in CSV",err)
//     }
//   }
  
//   const csvContent = convertToCSV(csvTable);
  
//   // Specify the file path
//   const filePath = 'sujeet_opcodes_filtered_trigrams_multilabeled_1.csv';
  
//   // Write the CSV content to the file
//   fs.writeFileSync(filePath, csvContent);
  
//   console.log(`CSV file has been created at ${filePath}`);
