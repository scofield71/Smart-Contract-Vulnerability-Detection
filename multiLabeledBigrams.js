const fs = require('fs');
const path = require('path');

function getAllFoldersInFolder(folderPath, folders = []) {
    const contents = fs.readdirSync(folderPath);
  
    contents.forEach(item => {
      const itemPath = path.join(folderPath, item);
      if (fs.statSync(itemPath).isDirectory()) {
        folders.push(itemPath);
        getAllFoldersInFolder(itemPath, folders);
      }
    });
  
    return folders;
  }

  const folderPath = './Classified_Opcodes_Filtered';
  const allFolders = getAllFoldersInFolder(folderPath);

const bigrams = new Set()

function readFilesSync(dir) {
    const files = [];

    fs.readdirSync(dir).forEach(filename => {
        const name = path.parse(filename).name;
        const ext = path.parse(filename).ext;
        const filepath = path.resolve(dir, filename);
        const stat = fs.statSync(filepath);
        const isFile = stat.isFile();

        if (isFile) files.push({ filepath, name, ext, stat });
    });
    console.log("All files extracted");
    return files;
}

function generateBigrams(text) {
    const words = text.split(/\s+/);
  
    for (let i = 0; i < words.length - 1; i++) {
      bigrams.add(words[i].concat('-').concat(words[i+1]));
    }
}

allFolders.forEach(folder => {
    const files = readFilesSync(`${folder}/`)

    for(let i=0;i<files.length;i++)
    {
        try{
            let file = files[i]
    
            const data = fs.readFileSync(file.filepath, 'utf8');
            generateBigrams(data)
    
            //console.log(`File ${i} successfully read`);
        }catch(err){
            console.log("This file has some issue ",err)
        }
    }
})

const csvTable = []

let allFileNames = new Set()

let mapOfVulnerability = {};

allFolders.forEach(folder => {
    const files = readFilesSync(`${folder}/`)

    for(let i=0;i<files.length;i++)
    {
       // console.log(files[i].name);
       if(mapOfVulnerability[files[i].name])
       {
        mapOfVulnerability[files[i].name].push(folder)
       }else
       {
        mapOfVulnerability[files[i].name] = []
        mapOfVulnerability[files[i].name].push(folder)
       }
    }
})

allFolders.forEach(folder => {

    const files = readFilesSync(`${folder}/`)

    for(let i=0;i<files.length;i++)
    {
        try{

            let file = files[i]
            if(!allFileNames.has(file.name)){
                allFileNames.add(file.name);


                const text = fs.readFileSync(file.filepath,'utf8');
                const words = text.split(/\s+/);
        
                const map = new Map([])
        
                for (let i = 0; i < words.length - 1; i++){
                    if(map.has(words[i].concat('-').concat(words[i+1]))){
                        map.set(words[i].concat('-').concat(words[i+1]),parseInt(map.get(words[i].concat('-').concat(words[i+1]),10))+1);
                    }else{
                        map.set(words[i].concat('-').concat(words[i+1]),1);
                    }
                }
        
                const row = new Map([])
        
                for(const feature of bigrams){
                    if(map.has(feature))
                    {
                        row.set(feature,parseInt(map.get(feature))/(words.length - 1))
                    }else{
                        row.set(feature,0);
                    }
                }
                
                for(let j=0;j<allFolders.length;j++)
                {
                    let ck=0;
                    for(let l=0;l<mapOfVulnerability[file.name].length;l++)
                    {
                        if(allFolders[j]===mapOfVulnerability[file.name][l])
                        {
                            ck=1;
                            break;
                        }
                    }
                    if(ck===0) row.set(allFolders[j],0);
                    else row.set(allFolders[j],1);
                }

                csvTable.push(row);
                console.log(`${i} file pushed in csvTable`);
            }

        }catch(err){
            console.log("This file has some issue ",err);
        }
    }
})

function convertToCSV(data) {
    try{
        let headerArr = []
        for(let [key,value] of csvTable[0])
        {
            headerArr.push(key);
        }
        const header = headerArr.join(',');
        const rows = []
        for(let obj of csvTable)
        {
            let tmp = []
            for(let [key,value] of obj){
                tmp.push(value)
            }
            let row = tmp.join(',');
            rows.push(row);
        }
        return [header, ...rows].join('\n');
    }catch(err){
        console.log("Can't be converted in CSV",err)
    }
  }
  
  const csvContent = convertToCSV(csvTable);
  
  // Specify the file path
  const filePath = 'classified_opcodes_filtered_bigrams_multilabeled.csv';
  
  // Write the CSV content to the file
  fs.writeFileSync(filePath, csvContent);
  
  console.log(`CSV file has been created at ${filePath}`);